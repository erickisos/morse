= Morse
Fogus
2023-04-20
:type: guides
:toc: macro
:icons: font

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

toc::[]

[[introduction]]

== Why Morse?
One of the prime value propositions in using a Lisp language is that you should be able to interact with your live program. The typical access mechanism for Clojure programs is the REPL, but its print-oriented streaming nature limits interactive and graphical data exploration.

Morse, like REBL before it, is a library that provides a graphical browser for Clojure data that allows active traversal into and back out of nested structures. REBL was intended to sit in the middle of your editor<->process REPL streams and automatically render and cache all REPL results. This made it difficult to integrate in dev environments that used other than raw streaming REPLs. In Morse the emphasis is now on inspecting on demand via the `inspect` API, and REPL interception is strictly optional. This should make Morse easy to integrate with all dev setups.

It's not always feasible to execute a graphical browser process inside of the program process, e.g. when the inspected program is running remotely. Morse can be configured to connect to and inspect a remote program, a facility built on the new Replicant* libraries. Morse uses Replicant to efficiently and incrementally traverse remote data, extending its power to a variety of new use cases.

== Clojure, Morse and the Lisp Value Proposition
Clojure lets programmers solve problems by staying connected to their running programs and live data, incrementally building up both the program and their understanding of the problem they are trying to solve. Morse, Replicant, and the new add-libs features of Clojure version 1.12.0-alpha3 all work together to amplify the power of the programmer during interactive development.

This software is considered an alpha release and subject to change.

**More about Morse**

* link:./ui.adoc[Morse user guide] *this document*
* link:./ui.adoc[Morse User Interface guide]

== Usage

Morse has two inspection modes: in-process and remote. In this section we'll outline some common use cases and describe how to use Morse in each case.

[[in-proc]]
=== Running Morse in your application process

Morse can run inside of your application process and access its full power. To add Morse as a `:dev` dependency, simply add the following to your deps.edn file:

[source,clojure]
----
:aliases
{:dev
  {:extra-deps {io.github.nubank/morse {:git/tag "v2023.04.25.01" :git/sha "f7a719e"}}}
}
----

With this dependency in place you can run your Clojure REPL with the `:dev` alias active to make Morse available on the classpath:

[source,bash]
----
clj -A:dev
----

You can then launch the Morse UI using `requiring-resolve`, shown below:

[source,clojure]
----
((requiring-resolve 'dev.nu.morse/launch-in-proc))
----

The Morse API provides an `inspect` function taking an object and displaying it in the Morse UI. 

[source,clojure]
----
(dev.nu.morse/inspect {:a 1 :b 2})
----

You should see the map `{:a 1 :b 2}` in the data Morse data browser.

Having Morse available as a nimble data inspector in your development process provides a powerful lever for understanding application state and data collections.

==== Bootstrap Morse in your running process

In version 1.12.0-alpha3 and beyond, Clojure provides a capability to add dependencies at run-time using the `add-lib` function available in the REPL. If your application process is running in a REPL then you can leverage Morse as needed by executing the following steps. This capability relies on https://clojure.org/guides/deps_and_cli[Clojure CLI] 1.11.1.1267 or later to function.

First, in your running process you can add the Morse library at run-time using the `add-lib` function to load the latest version:

[source,clojure]
----
(add-lib 'io.github.nubank/morse)
----

This should load the Morse dependency into the running process which will allow you use `requiring-resolve` to launch Morse as shown earlier:

[source,clojure]
----
((requiring-resolve 'dev.nu.morse/launch-in-proc))
----

[[out-of-process]]
=== Connecting Morse to a remote process

Morse Remote inspection requires two parts to operate. First, a server component link:https://github.com/clojure/replicant-server[replicant-server] runs in the process you wish to inspect (often your REPL). Second, Morse itself acts as a client to that active Replicant server.

In the deps.edn file for the process that you would like to inspect, add the following:

[source,clojure]
----
{:dev
  {:extra-deps
    {io.github.clojure/data.alpha.replicant-server {:git/tag "v2023.04.20.01" :git/sha "8c02f64"}}}
}
----

After starting the process, you can run the following to start a remote Replicant:

[source, clojure]
----
(require '[clojure.data.alpha.replicant.server.prepl :as rs])
(rs/start-replicant)
----

By default, replicant-server runs on localhost port 5555 but is configurable per the instructions in the link:https://github.com/clojure/replicant-server[replicant-server] repository.

Next, add Morse as a `:dev` dependency to a different application project by inserting the following to your deps.edn file:

[source,clojure]
----
:aliases
{:dev
  {:extra-deps {io.github.nubank/morse {:git/tag "v2023.04.25.01" :git/sha "f7a719e"}}}
}
----

You can then launch the Morse UI using `requiring-resolve`, shown below:

[source,clojure]
----
((requiring-resolve 'dev.nu.morse/launch-remote))
----

Once connected, the REPL pane in Morse is a remote client of the server (via a socket) of an active link:https://github.com/clojure/data.alpha.replicant-server[Replicant server]. Expressions you type into Morse are evaluated in the context of the process hosting the Replicant server. This is just like any remote socket-based repl.

You can supply an options map to the function loaded by `requiring-resolve` to match the target replicant-server. The function `dev.nu.morse/launch-remote` takes two mappings `:host->host-string` and `:port->port-number`. By default, the function `dev.nu.morse/launch-remote` operates as if the following options map was supplied:

[source,clojure]
----
((requiring-resolve 'dev.nu.morse/launch-remote) {:host "localhost", :port 5555})
----

[[out-of-process-bootstrap]]
==== Bootstraping Morse for remote inspection

In version 1.12.0-alpha3 and beyond, Clojure provides a capability to add dependencies at run-time using the `add-lib` function available in the REPL. If your application process is running in a REPL then you can leverage Morse as needed by executing the following steps. This capability relies on https://clojure.org/guides/deps_and_cli[Clojure CLI] 1.11.1.1267 or later to function.

First, in your running process you can add the link:https://github.com/clojure/data.alpha.replicant-server[replicant-server] library at run-time using the `add-lib` function to load the latest version:

[source,clojure]
----
(add-lib 'io.github.clojure/data.alpha.replicant-server)
----

This should load the replicant-server dependency into the running process which will allow you to `require` the Replicant namespace and start as server as outlined in the previous section.

Next, in a separate process you can add the Morse library at run-time using the `add-lib` function to load the latest version:

[source,clojure]
----
(add-lib 'io.github.nubank/morse)
----

This should load the Morse dependency into the running process which will allow you use `requiring-resolve` to launch Morse as shown earlier:

[source,clojure]
----
((requiring-resolve 'dev.nu.morse/launch-remote))
----

[[tool-install]]
==== Installing Morse as a Clojure CLI tool

Morse is available as a Clojure CLI tool and may be installed and upgraded via:

    clj -Ttools install-latest :lib io.github.nubank/morse :as morse

That command installs a tool named "morse" that you can launch via:

    clj -Tmorse morse <options>

The <options> are optional mappings `:host->host-string` and `:port->port-number` mappings. If omitted, <options> default to `:host '"localhost"' :port 5555`.

[[requirements]]
== Requirements

* Clojure, 1.10.0 or higher
* Java 11 or higher



